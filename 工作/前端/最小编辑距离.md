### 72. Edit Distance

Given two strings `word1` and `word2`, return *the minimum number of operations required to convert `word1` to `word2`*.

You have the following three operations permitted on a word:

- Insert a character
- Delete a character
- Replace a character

 

**Example 1:**

```
Input: word1 = "horse", word2 = "ros"
Output: 3
Explanation: 
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')
```

**Example 2:**

```
Input: word1 = "intention", word2 = "execution"
Output: 5
Explanation: 
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')
```

 

**Constraints:**

- `0 <= word1.length, word2.length <= 500`
- `word1` and `word2` consist of lowercase English letters.



---



### 递归法解

假设 word1 的长度是 m ，word2 的长度是 n ，要求 word1[1]word1[2]...word1[m] => word2[1]word2[2]...word2[n] 的最小编辑距离，记为 d\[m][n]。

1. 假设 word1[m] \=== word2[n]，那么 d\[m][n] === d\[m-1][n-1]。比如，"xyz" => "pqz" 的最小编辑距离等于 "xy" => "pq"的最小编辑距离
2. 如果 word1[m] !== word[n]，分为三种情况
   - 比如，"xyz" => "efg" 的最小编辑距离等于 "xy" => "efg" 的最小编辑距离 + 1 （因为允许删除操作，"xyz" =>"efgz" 后再删除一个 z 即可），于是 d\[m][n] === d\[m-1][n] + 1。
   - 同上 "xyz" => "efg" 的最小编辑距离等于 "xyz" => "ef" 的最小编辑距离 + 1（因为允许插入操作，"xyz" => "ef" 后再插入一个 "g" 即可）。于是 d\[m][n] === d\[m][n-1] + 1。
   - 同上 "xyz" => "efg" 的最小编辑距离等于 "xy" => "ef" 的最小编辑距离 + 1 （因为允许替换操作，"xyz" => "efz" 后 替换 "z" => "g" 即可）。于是 d\[m][n] === d\[m-1][n-1] + 1。

3. 如果 word1 的长度为 0，那么 word1 => word2 的最小编辑距离为 word2 的长度；反过来，如果 word2 的长度为 0，那么 word1 => word2 的最小编辑距离为 word1 的长度。

代码实现

```javascript
/**
 * 最短编辑距离递归算法
 * @param word1 {String} word1
 * @param word2 {String} word2
 * @param i {number} word1 的长度
 * @param j {number} word2 的长度
 * @return word1 => word2 的最短编辑距离
 */
function recursion(word1, word2, i, j) {
  if (i === 0) return j;
  if (j === 0) return i;
  // word 的最后一位是 word[word.length -1]
  if (word1[i - 1] === word2[j - 1]) {
    return recursion(word1, word2, i - 1, j - 1);
  } else {
    let m1 = recursion(word1, word2, i, j - 1) + 1;
    let m2 = recursion(word1, word2, i - 1, j) + 1;
    let m3 = recursion(word1, word2, i - 1, j - 1) + 1;
    return Math.min(m1, m2, m3);
  }
}
```

### 动态规划实现

动态规划看起来跟递归很像，不过推理逻辑正好是反过来的。递归的逻辑是：“要求得 d\[m][n]，先要求得 d\[m-1][n-1]……”，动态规划的逻辑是：“先求得 d\[m-1][n-1]，再求 d\[m][n]……”这是它们的主要区别。

```javascript
/**
 * 最短编辑距离动态规划算法
 * @param word1
 * @param word2
 */
function dynamicProgramming(word1, word2) {
  const len1 = word1.length;
  const len2 = word2.length;
  const dp = new Array(len1 + 1).fill(undefined).map((el) => new Array(len2 + 1));
  for (let j = 0; j <= len2; j++) {
    dp[0][j] = j;
  }
  for (let i = 0; i <= len1; i++) {
    dp[i][0] = i;
  }
  for (let i = 1; i <= len1; i++) {
    for (let j = 1; j <= len2; j++) {
      // word 的最后一位是 word[word.length -1]
      if (word1[i - 1] === word2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        let m1 = dp[i - 1][j] + 1;
        let m2 = dp[i][j - 1] + 1;
        let m3 = dp[i - 1][j - 1] + 1;
        dp[i][j] = Math.min(m1, m2, m3);
      }
    }
  }
  return dp[len1][len2];
}
```



