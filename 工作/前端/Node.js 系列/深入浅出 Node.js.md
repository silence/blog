本文为 《深入浅出 Node.js》的重点摘抄。

### 第 1 章 Node 简介

#### 1.2 Node 的命名与起源

##### 1.2.1 为什么是 JavaScript

考虑到高性能、符合事件驱动、没有历史包袱这 3 个主要原因，JavaScript 成为了 Node 的实现语言。

##### 1.2.2 为什么叫 Node

Node 发展为一个强制不共享任何资源的单线程、单进程系统，包含十分适宜网络的库，为构建大型分布式应用程序提供基础设施，其目标也是**成为一个构建快速、可伸缩的网络应用平台**。它自身非常简单，通过通信协议来组织许多 Node，非常容易通过扩展来达成构建大型网络应用的目的。每一个 Node 进程都构成这个网络应用中的一个节点，这是它名字所含意义的真谛。

#### 1.4 Node 的特点

##### 1.4.1 异步 I/O

异步调用中对于结果值的捕获是符合 “**Don't call me, I will call you**” 的原则的，这也是注重结果，不关心过程的一种表现。

##### 1.4.2 事件与回调函数

##### 1.4.3 单线程

单线程的最大好处是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换所带来的性能上的开销。

同样，单线程的弱点具体有以下 3 个方面。

- 无法利用多核 CPU。
- 错误会引起整个应用退出，应用的健壮性值得考验。
- 大量计算占用 CPU 导致无法继续调用异步 I/O。

像浏览器中 JavaScript 与 UI 共用一个线程一样，JavaScript 长时间执行会导致 UI 的渲染和响应被中断。在 Node 中，长时间的 CPU 占用也会导致后续的异步 I/O 发不出调用，已完成的异步 I/O 的回调函数也会得不到及时执行。

在 HTML5 中，Web Workers 能够创建工作线程来进行计算，以解决 JavaScript 大计算阻塞 UI 渲染的问题。工作线程为了不阻塞主线程，通过消息传递的方式来传递运行结果，这也使得工作线程不能访问到主线程中的 UI。

Node 采用了与 Web Workers 相同的思路来解决单线程中大计算量的问题：child_process。

子进程的出现，意味着 Node 可以从容地应对单线程在健壮性和无法利用多核 CPU 方面的问题。通过将计算分发到各个子进程，可将大量计算分解掉，然后再通过进程之间的事件消息来传递结果，这可以很好地保持应用模型的简单和低依赖。通过 **Master-Worker** 的管理方式，也可以很好地管理各个工作进程，以达到更高的健壮性。

##### 1.4.4 跨平台

它在操作系统与 Node 上层模块系统之间构建了一层**平台层架构**，即 **libuv**。目前，libuv 已经成为许多系统实现跨平台的基础组件。关于 libuv 的设计，我们将在第 3 章中介绍。

#### 1.5 Node 的应用场景

关于 Node，探讨得较多的主要有 I/O 密集型和 CPU 密集型。

##### 1.5.1 I/O 密集型

Node 面向网络且擅长并行 I/O，能够有效地组织起更多的硬件资源，从而提供更多好的服务。

I/O 密集的优势主要在于 **Node 利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。**

##### 1.5.2 是否不擅长 CPU 密集型业务

CPU 密集型应用给 Node 带来的挑战主要是：由于 JavaScript 单线程的原因，如果有长时间运行的计算（比如大循环），将会导致 CPU 时间片不能释放，使得后续 I/O 无法发起。但是适当调整和分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞 I/O 调用的发起，这样既可同时享受到并行异步 I/O 的好处，又能充分利用 CPU。

对于长时间运行的计算，Node 虽然没有提供多线程用于计算支持，但是还是有以下两个方式来充分利用 CPU。

- Node 可以通过编写 C/C++ 扩展的方式更高效地利用 CPU，将一些 V8 不能做到性能极致的地方通过 C/C++ 来实现。由上面的测试结果可以看到，通过 C/C++ 扩展的方式实现斐波那契数列计算，速度比 Java 还快。
- 如果单线程的 Node 不能满足需求，甚至用了 C/C++ 扩展后还觉得不够，那么通过子进程的方式，将一部分 Node 进程当做常驻服务进程用于计算，然后利用进程间的消息来传递结果，将计算与 I/O 分离，这样还能充分利用多 CPU。

CPU 密集不可怕，如何合理调度是诀窍。

##### 1.5.4 分布式应用

阿里巴巴的数据平台对 Node 的分布式应用算是一个典型的例子。分布式应用意味着对可伸缩性的要求非常高。数据平台通常要在一个数据库集群中去寻找需要的数据。阿里巴巴开发了中间层应用 NodeFox、ITier，将数据库集群做了划分和映射，查询调用依旧是针对单张表进行 SQL 查询，中间层分解查询 SQL，并行地去多台数据库中获取数据并合并。NodeFox 能实现对多台 MySQL 数据库的查询，如同查询一台 MySQL 一样，而 ITier 更强大，查询多个数据库如同查询单个数据库一样，这里的多个数据库是指不同的数据库，如 MySQL 或其他数据库。

### 第 2 章 模块机制

#### 2.2 Node 的模块实现

在 Node 中引入模块，需要经历如下 3 个步骤。

1. 路径分析
2. 文件定位
3. 编译执行

在 Node 中，模块分为两类：一类是 Node 提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。

- 核心模块部分在 Node 源代码的编译过程中，编译进了二进制执行文件。在 Node 进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的。
- 文件模块则是在运行时动态加载，需要完整的**路径分析、文件定位、编译执行**过程，速度比核心模块慢。

接下来，我们展开详细的模块加载过程。

##### 2.2.1 优先从缓存加载

展开介绍路径分析和文件定位之前，我们需要知晓的一点是，与前端浏览器会缓存静态脚本文件以提高性能一样，Node 对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的地方在于，**浏览器仅仅缓存文件，而 Node 缓存的是编译和执行之后的对象**。

不论是核心模块还是文件模块，**require() 方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查。**

##### 2.2.2 路径分析和文件定位

因为标识符有几种方式，对于不同的标识符，模块的查找和定位有不同程度上的差异。

1. 模块标识符分析

前面提到过，require() 方法接受一个标识符作为参数。在 Node 实现中，正是基于这样一个标识符进行模块查找的。模块标识符在 Node 中主要分为以下几类。

- 核心模块，如 http、fs、path 等。

- . 或 .. 开始的相对路径文件模块。
- 以 / 开始的绝对路径文件模块。
- 非路径形式的文件模块，如自定义的 connect 模块。

[1] 核心模块

核心模块的优先级仅次于缓存加载，它在 Node 的源代码编译过程中已经编译为二进制代码，其加载过程最快。

如果试图加载一个与核心模块标识符相同的自定义模块，那是不会成功的。如果自己编写了一个 http 用户模块，想要加载成功，必须选择一个不同的标识符或者换用路径的方式。

[2] 路径形式的文件模块

以 .、.. 和 / 开头标识符，这里都被当做文件模块来处理。在分析路径模块时，require() 方式会将路径转为真实路径，并以真实路径作为索引，将编译执行后的结果存放到缓存中，以使二次加载时更快。

由于文件模块给 Node 指明了确切的文件位置，所以在查找过程中可以节约大量时间，其加载速度慢于核心模块。

[3] 自定义模块

自定义模块指的是非核心模块，也不是路径形式的标识符。它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。

在介绍自定义模块的查找方式之前，需要先介绍一下 模块路径 这个概念。

模块路径是 Node 在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。关于这个路径的生成规则，我们可以手动尝试一番。

(1). 创建 *module_path.js* 文件，其内容为 console.log(module.paths);。

(2). 将其放到任意一个目录中然后执行 node *module_path.js*。

在 Linux 下，你可能得到的是这样一个数组输出：

['/home/jackson/research/node_modules', '/home/jackson/node_modules', '/home/node_modules', '/node_modules']

而在 windows 下，也许是这样：

['c:\\\\nodejs\\\\node_modules', 'c:\\\\node_modules']

可以看出，模块路径的生成规则如下所示。

- 当前文件目录下的 node_modules 目录。
- 父目录下的 node_modules 目录。
- 父目录的父目录下的 node_modules 目录。
- 沿路径向上逐级递归，直到根目录下的 node_modules 目录。

它的生成方式与 JavaScript 的原型链或作用域链的查找方式十分类似。在加载的过程中，Node 会逐个尝试模块路径中的路径，直到找到目标文件为止。可以看出，当前文件的路径越深，模块查找耗时会越多，这是自定义模块的加载速度是最慢的原因。

2. 文件定位

从缓存加载的优化策略使得二次引入时不需要路径分析、文件定位和编译执行的过程，大大提高了再次加载模块时的效率。

但在文件的定位过程中，还有一些细节需要注意，这主要包括文件扩展名的分析、目录和包的处理。

- 文件扩展名的分析

  require() 在分析标识符的过程中，会出现标识符中不包含文件拓展名的情况。CommonJS 模块规范也允许在标识符中不包含文件拓展名，这种情况下，**Node 会按 .js、.json、.node 的次序补足拓展名，依次尝试**。

  在尝试的过程中，需要调用 fs 模块同步阻塞式地判断文件是否存在。因为 Node 是单线程的，所以这里是一个会引起性能问题的地方。小诀窍是：如果是 .node 和 .json 文件，在传递给 require() 的标识符中带上拓展名，会加快一点速度。另一个诀窍是：同步配合缓存，可以大幅度缓解 Node 单线程中阻塞式调用的缺陷。
  
- 目录分析和包
  
  在分析标识符的过程中，require() 通过分析文件扩展名之后，可能没有查找到对应文件，但却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，**此时 Node 会将目录当做一个包来处理。**
  
  在这个过程中，Node 对 CommonJS 包规范进行了一定程度的支持。首先，Node 在当前目录下查找 package.json（CommonJS 包规范定义的包描述文件），通过 JSON.parse() 解析出包描述对象，**从中取出 main 属性指定的文件名进行定位，或者压根没有 package.json 文件，Node 会将 index 当做默认文件名，然后依次查找 index.js、index.json、index.node**。
  
  如果在目录分析的过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依然没有查找到目标文件，则会抛出查找失败的异常。

##### 2.2.3 模块编译

在 Node 中，每个文件模块都是一个对象，它的定义如下：

```javascript
function Module(id, parent) {
  this.id = id;
  this.exports = {};
  this.parent = parent;
  if (parent && parent.children) {
    parent.children.push(this);
  }
  
  this.filename = null;
  this.loaded = false;
  this.children = [];
}
```

编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node 会新建一个模块对象，然后根据路径载入并编译。对于不同的文件扩展名，其载入方法也有所不同，具体如下所示。

- **.js 文件**。通过 fs 模块**同步**读取文件后编译执行。
- **.node 文件**。这是用 C/C++ 编写的扩展文件，通过 dlopen() 方法加载最后编译生成的文件。
- **.json 文件**。通过 fs 模块同步读取文件后，用 JSON.parse() 解析返回结果。
- **其余扩展名文件**。它们都被当做 .js 文件载入。

每一个编译成功的模块都会将其文件路径作为索引缓存在 Module._cache 对象上，以提高二次引入的性能。

**根据不同的文件扩展名，Node 会调用不同的读取方式**。可以通过在代码中访问 require.extensions 可以自动系统中已有的扩展加载方式。

```javascript
console.log(require.extensions);
```

得到的执行结果如下：

```javascript
{ '.js': [Function], '.json': [Function], '.node': [Function] }
```

在确定文件的扩展名之后，Node 将调用具体的编译方式来将文件执行后返回给调用者。

1. JavaScript 模块的编译

在编译的过程中，Node 对获取的 JavaScript 文件内容进行头尾包装。在头部添加了 (function (exports, require, module, __filename, __dirname) {\n，在􏰽尾部添􏰹加了\n});

一个正常的 JavaScript 文件会被包装成如下的样子：

```javascript
(function (exports, require, module, __filename, __dirname) { 
  var math = require('math');
	exports.area = function (radius) {
	return Math.PI * radius * radius; 
  };
});
```

这样每个模块文件之间都进行作用域隔离。包装之后的代码会通过 vm 原生模块的 runInThisContext() 方法执行（类似 eval，只是具有明确上下文，不污染全局），返回一个具体的 function 对象。最后，将当前模块对象的 exports 属性、require() 方法、module（模块对象自身），以及在文件定位中得到的**完整文件路径**(__filename)和**文件目录**(\_\_dirname)作为参数传递给这个 function() 执行。

这就是这些变量并没有定义在每个模块文件中却存在的原因。在执行之后，模块的 exports 属性被返回给了调用方。exports 属性上的任何方法和属性都可以被外部调用到，但是模块中的其余变量或属性则不可直接被调用。

至此，require、exports、module 的流程已经完整，这就是 Node 对 CommonJS 模块规范的实现。



