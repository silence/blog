给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]\*k[1]*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

```
示例 1：

输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
```

```
示例 2:

输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
```


提示：

2 <= n <= 1000

---

本题涉及到求余方法：

方法一：循环求余

> 求余性质：(xy) % p = [(x % p) * (y % p)] % p

所以 x^a^ % p = [(x^a-1^ % p)(x % p)] % p = [(x^a-1^ % p) * x] % p

根据此公式，可以通过循环求出 x^1^，x^2^，...，x^a-1^，x^a^ 对 p 的余数。

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var cuttingRope = function(n) {
  // 此处计算方法参考 14-I 剪绳子
  if (n === 2) return 1; 
  if (n === 3) return 2;
  const yu = n % 3;
  const N = parseInt(n/3)
  if (yu === 0) return reminder(3, n/3, 1000000007); 
  if (yu === 1) return (reminder(3, N - 1, 1000000007) * 4) % 1000000007;
  
  if (yu === 2) return (reminder(3, N, 1000000007) * 2) % 1000000007;
  
};

// 求 (a ** n) % p
var reminder= function(a, n, p) {
  // (a ** n) % p = (a ** (n-1) * a) % p = ( a ** (n-1) % p * a % p) % p = (a ** (n-1) % p * a) % p
  let prevRem = a % p;
  if (n === 0) return 1
  if (n === 1) return prevRem;
  for (let i = 2; i <= n; i++) {
    prevRem = (prevRem  * a) % p
  }
  return prevRem;
}
```

方法二：快速幂求余

x^a^ % p = (x^2^)^a/2^ % p = (x^2^ % p)^a/2^ % p

然后分为两种情况

- a 为偶数时，x^a^ % p = (x^2^ % p)^a/2^ % p
- a 为奇数时，x^a^ % p = [(x % p)(x^a-1^ % p)] % p = [x(x^2^ % p)^(a-1)/2^] % p

利用上述公式，可以通过循环操作每次把指数 a 问题降低至 指数 a // 2 问题，只需循环 log~2~(N) 次，可以将复杂度降低至对数级别。

```javascript
// 求 (x ** a) % p --- 快速幂求余
var reminder = function (x, a, p) {
  let rem = 1;
  while(a > 0) {
    // a 为奇数，循环结束时 a = 1
    if (a % 2 !== 0) {
      rem = (rem * x) % p
    }
    x = x ** 2 % p
    a = parseInt(a / 2)
  }
  return rem;
}
```

