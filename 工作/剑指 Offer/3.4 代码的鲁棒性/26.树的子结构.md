输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

例如:
给定的树 A:

       3
      / \
     4   5
    / \
    1  2

给定的树 B：

```
  4 
 /
1
```

返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。

```
示例 1：

输入：A = [1,2,3], B = [3,1]
输出：false
```

```
示例 2：

输入：A = [3,4,5,1,2], B = [4,1]
输出：true
```

限制：

0 <= 节点个数 <= 10000

---

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} A
 * @param {TreeNode} B
 * @return {boolean}
 */
var isSubStructure = function(A, B) {
  // 定义一个用来判断 B 是否是 A 的子结构的递归函数，头结点不同直接返回 false。
  // 头结点相同的情况下递归判断 B 是否是 A 的子结构
  var recur = function (A, B) {
    if (B === null) return true;
    if (A === null || A.val !== B.val) return false;
    return recur(A.left, B.left) && recur(A.right, B.right);
  }
	
  // dfs A 的每个节点判断 B 是否是 A 的子树。因为 || 的递归阻断效应，遇到 true 返回后即不再递归。
  return (A !== null && B !== null) && (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B))
};
```

时间复杂度: O(MN)

空间复杂度: O(M)

