输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

 

例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

    	 3
    	/ \
      9 20
        / \
       15  7



限制：

0 <= 节点个数 <= 5000

---

方法：前序遍历是先根节点再左节点再右节点，中序遍历是先左节点再根节点再右节点。

1. 先通过前序遍历找到根节点。
2. 通过根节点的值找到在中序遍历中的根节点索引。
3. 通过中序遍历中根节点的索引，将中序遍历划分为左子树和右子树。
4. 通过中序遍历中根节点的索引，将前序遍历划分为左子树和右子树。（**中序遍历根节点的索引也能恰好将前序遍历划分为左子树和右子树**）
5. 左右子树分别递归构建。

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function(preorder, inorder) {
  if (preorder.length === 0) return null;
  let preorderRoot = preorder[0];
  let inorderRootIndex = inorder.findIndex((value) => value === preorderRoot);
  const tree = new TreeNode(preorderRoot);
  // 构建左子树
  const preorderLeft = preorder.slice(1, inorderRootIndex + 1);
  const inorderLeft = inorder.slice(0, inorderRootIndex);
  tree.left = buildTree(preorderLeft, inorderLeft);

  // 构建右子树
  const preorderRight = preorder.slice(inorderRootIndex + 1);
  const inorderRight = inorder.slice(inorderRootIndex + 1);
  tree.right = buildTree(preorderRight, inorderRight)


  return tree
};
```

