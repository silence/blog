地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

```
示例 1：
输入：m = 2, n = 3, k = 1
输出：3
```

```
示例 2：
输入：m = 3, n = 1, k = 0
输出：1
```

提示：

1 <= n,m <= 100
0 <= k <= 20

---

方法：

1. DFS

数位和的计算方法

```javascript
var calculateBitSum = function(x) {
  var res = 0;
  while(x !== 0) {
    res += x % 10
    x = parseInt(x / 10)
  }
  return res
}
```

但其实已知一个值 x 和 它的数位和 xBitSum，则可以推导出 x + 1 的数位和 xBitSumNext

```javascript
/**
 * 计算 x + 1 的数位和，例：
 *
 * 19 的数位和是 10，20的数位和是 8.
 *
 * 23 的数位和是 5，24 的数位和是 6
 */
var calculateBitSumNext = function(x, xBitSum) {
  return (x + 1) % 10 === 0 ? xBitSum - 8 : xBitSum + 1;
}
```

因为 100 以内的数快满 10 进位后，十分位数 + 1 ，个分位数由 9 变为 0 ，固 `(x + 1) % 10 === 0` 的数的下一个数的数位和为 `xBitSum - 8`。

```javascript
/**
  * 计算 x + 1 的数位和，例：
  *
  * 19 的数位和是 10，20的数位和是 8.
  *
  * 23 的数位和是 5，24 的数位和是 6
  */
  var calculateBitSumNext = function(x, xBitSum) {
    return (x + 1) % 10 === 0 ? xBitSum - 8 : xBitSum + 1;
  }
  
/**
 * @param {number} m
 * @param {number} n
 * @param {number} k
 * @return {number}
 */
var movingCount = function(m, n, k) {
  // 记录访问过了的坐标 key e.g.`1,2`
  var visited = {}

  var dfs = function (i, j, iBitSum, jBitSum) {
    // 数组越界
    if (i > (m - 1) || j > (n - 1)) return 0;
    // 访问过了
    if (visited[`${i},${j}`]) return 0;

    visited[`${i},${j}`] = true;
    var res = 1

    var iBitSumNext = calculateBitSumNext(i, iBitSum)
    var jBitSumNext = calculateBitSumNext(j, jBitSum)
		// 当前格子的右边格子的数位和
    if ((iBitSumNext + jBitSum) <= k) {
      res += dfs(i + 1, j, iBitSumNext, jBitSum)
    }
		// 当前格子的下边格子的数位和
    if ((jBitSumNext + iBitSum) <= k) {
      res += dfs(i, j + 1, iBitSum, jBitSumNext)
    }

    return res
  }

  return dfs(0, 0, 0, 0)
};
```

2. BFS

```javascript
/**
  * 计算 x + 1 的数位和，例：
  *
  * 19 的数位和是 10，20的数位和是 8.
  *
  * 23 的数位和是 5，24 的数位和是 6
  */
  var calculateBitSumNext = function(x, xBitSum) {
    return (x + 1) % 10 === 0 ? xBitSum - 8 : xBitSum + 1;
  }

var movingCount = function(m, n, k) {
  // 记录访问过了的坐标 key e.g.`1,2`
  let visited = {}
  // 用一个队列来维持 BFS 的顺序
  const BFSQueue = []
  BFSQueue.push([0, 0, 0, 0]);
  let res = 0
  while(BFSQueue.length !== 0) {
    const [i, j, iBitSum, jBitSum] = BFSQueue.shift();
    // 数组越界
    if (i > (m - 1) || j > (n - 1)) continue;
    // 访问过了
    if (visited[`${i},${j}`]) continue;
    
    visited[`${i},${j}`] = true;
    res ++;
    const iBitSumNext = calculateBitSumNext(i, iBitSum)
    const jBitSumNext = calculateBitSumNext(j, jBitSum)
    // 当前格子的右边格子的数位和
    if ((iBitSumNext + jBitSum) <= k) {
      BFSQueue.push([i + 1, j, iBitSumNext, jBitSum])
    }
		// 当前格子的下边格子的数位和
    if ((jBitSumNext + iBitSum) <= k) {
      BFSQueue.push([i, j + 1, iBitSum, jBitSumNext])
    }

  }
  return res;
}
```



