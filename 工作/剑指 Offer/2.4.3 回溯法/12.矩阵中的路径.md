给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

 

例如，在下面的 3×4 的矩阵中包含单词 "ABCCED"（单词中的字母已标出）。

![image-20210605141517052](https://raw.githubusercontent.com/silence/blog/assets/assets/20210605141517.png)

```
示例 1：
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```
```
示例 2：
输入：board = [["a","b"],["c","d"]], word = "abcd"
输出：false
```


提示：

1 <= board.length <= 200
1 <= board[i].length <= 200
board 和 word 仅由大小写英文字母组成

---

方法：典型的矩阵搜索问题，使用 DFS + 剪枝 解决

剪枝：在搜索中，若遇到 `这条路不可能和目标字符串匹配成功（例如：当前元素和目标字符串不同、此元素已经被访问过了）` 则直接返回。

```javascript
/**
 * @param {character[][]} board
 * @param {string} word
 * @return {boolean}
 */
var exist = function(board, word) {
  const height = board.length;
  const width = board[0].length;

  var dfs = function (board, i, j, word) {
    // 横坐标越界
    if (i >= width || i < 0) return false;
    // 纵坐标越界
    if (j >= height || j < 0) return false;
    // 目标不相等
    if (board[j][i] !== word[0]) return false;
    // 已经访问过了
    if (board[j][i] === '') return false;
		// 完美找到，就靠着这个 true 一路递归向上返回
    if (word.length === 1)  return true;
    // 当前节点标记为已访问
    board[j][i] = ''
    // 向 上、下、左、右 四个方向寻找
    let res =  dfs(board, i, j + 1, word.slice(1)) || dfs(board, i + 1, j, word.slice(1)) || dfs(board, i - 1, j, word.slice(1)) || dfs(board, i, j -1 , word.slice(1))
    // 一轮查找完毕后记得还原
    board[j][i] = word[0];
    return res;
  }

  for (let i = 0; i < width; i++) {
    for (let j = 0; j < height; j++) {
      var res =  dfs(board, i, j, word)
      if (res) return res
    }
  }
  return false
};

```

